git-bundle(1)
=============

NAME
----
git-bundle - Move objects and refs by archive


SYNOPSIS
--------
[verse]
'git bundle' create [-q | --quiet | --progress | --all-progress] [--all-progress-implied]
		    [--version=<version>] <file> <git-rev-list-args>
'git bundle' verify [-q | --quiet] <file>
'git bundle' list-heads <file> [<refname>...]
'git bundle' unbundle <file> [<refname>...]

DESCRIPTION
-----------

Some workflows require that one or more branches of development on one
machine be replicated on another machine, but the two machines cannot
be directly connected, and therefore the interactive Git protocols (git,
ssh, http) cannot be used.

The 'git bundle' command packages objects and references in an archive
at the originating machine, which can then be imported into another
repository using 'git fetch', 'git pull', or 'git clone',
after moving the archive by some means (e.g., by sneakernet).

As no
direct connection between the repositories exists, the user must specify a
basis for the bundle that is held by the destination repository: the
bundle assumes that all objects in the basis are already in the
destination repository.

OPTIONS
-------

create [options] <file> <git-rev-list-args>::
	Used to create a bundle named 'file'.  This requires the
	'<git-rev-list-args>' arguments to define the bundle contents.
	'options' contains the options specific to the 'git bundle create'
	subcommand.

verify <file>::
	Used to check that a bundle file is valid and will apply
	cleanly to the current repository.  This includes checks on the
	bundle format itself as well as checking that the prerequisite
	commits exist and are fully linked in the current repository.
	'git bundle' prints a list of missing commits, if any, and exits
	with a non-zero status.

list-heads <file>::
	Lists the references defined in the bundle.  If followed by a
	list of references, only references matching those given are
	printed out.

unbundle <file>::
	Passes the objects in the bundle to 'git index-pack'
	for storage in the repository, then prints the names of all
	defined references. If a list of references is given, only
	references matching those in the list are printed. This command is
	really plumbing, intended to be called only by 'git fetch'.

<git-rev-list-args>::
	A list of arguments, acceptable to 'git rev-parse' and
	'git rev-list' (and containing a named ref, see SPECIFYING REFERENCES
	below), that specifies the specific objects and references
	to transport.  For example, `master~10..master` causes the
	current master reference to be packaged along with all objects
	added since its 10th ancestor commit.  There is no explicit
	limit to the number of references and objects that may be
	packaged.


[<refname>...]::
	A list of references used to limit the references reported as
	available. This is principally of use to 'git fetch', which
	expects to receive only those references asked for and not
	necessarily everything in the pack (in this case, 'git bundle' acts
	like 'git fetch-pack').

--progress::
	Progress status is reported on the standard error stream
	by default when it is attached to a terminal, unless -q
	is specified. This flag forces progress status even if
	the standard error stream is not directed to a terminal.

--all-progress::
	When --stdout is specified then progress report is
	displayed during the object count and compression phases
	but inhibited during the write-out phase. The reason is
	that in some cases the output stream is directly linked
	to another command which may wish to display progress
	status of its own as it processes incoming pack data.
	This flag is like --progress except that it forces progress
	report for the write-out phase as well even if --stdout is
	used.

--all-progress-implied::
	This is used to imply --all-progress whenever progress display
	is activated.  Unlike --all-progress this flag doesn't actually
	force any progress display by itself.

--version=<version>::
	Specify the bundle version.  Version 2 is the older format and can only be
	used with SHA-1 repositories; the newer version 3 contains capabilities that
	permit extensions. The default is the oldest supported format, based on the
	hash algorithm in use.

-q::
--quiet::
	This flag makes the command not to report its progress
	on the standard error stream.

SPECIFYING REFERENCES
---------------------

Revisions must accompanied by reference names to be packaged in a
bundle, since the header of the bundle is in a format similar to 'git
show-ref'.

More than one reference may be packaged, and more than one basis can
be specified.  The objects packaged are those not contained in the
union of the given bases.

By default 'git bundle create' resolves the reference names for you
with the same rules as `git rev-parse --abbrev-ref=loose` would. Each
basis can be specified explicitly (e.g. `^master~10`), or implicitly
(e.g. `master~10..master`, `--since=10.days.ago master`).

All of these simple cases are OK (assuming we have a "master" and
"next" branch):

----------------
$ git bundle create master.bundle master
$ echo master | git bundle create master.bundle --stdin
$ git bundle create master-and-next.bundle master next
$ (echo master; echo next) | git bundle create master-and-next.bundle --stdin
----------------

And so are these (and the same but omitted `--stdin` examples):

----------------
$ git bundle create recent-master.bundle master~10..master
$ git bundle create recent-updates.bundle master~10..master next~5..next
----------------

In the simple case, a revision name or a range whose right-hand-side
cannot be resolved to a reference is not accepted:

----------------
$ git bundle create HEAD.bundle $(git rev-parse HEAD)
fatal: Refusing to create empty bundle.
$ git bundle create master-yesterday.bundle master~10..master~5
fatal: Refusing to create empty bundle.
----------------

It is also possible to create a bundle with a revision or revision
range that does not resolve to a reference name, by explicitly
supplying the reference name to be used on `--stdin`. Provide the
rev-list argument that the "simple" mode accepts, followed by a tab
character and a fully-qualified reference name.

This allows for crafting bundles from arbitrary revision names or
ranges without having to alter the local set of references merely to
appease the bundle creation:

----------------
$ printf "e83c5163316f89bfbde7\trefs/heads/first-git-dot-git-commit\n" |
  git bundle create initial.bundle --stdin
$ printf "master~10..master~5\trefs/tags/some-master-pushes\n" |
  git bundle create master-pushes.bundle --stdin
----------------

It is also possible to mix and match the two forms, i.e. to have some
lines be tab-separated, and have others implicitly parse reference
from the provided revision:

----------------
$ (echo next ; printf "master~10..master~5\trefs/tags/some-master-pushes\n" |
  git bundle create next-and-some-master-pushes.bundle --stdin
----------------

For convenience we'll accept the output emitted by
linkgit:git-for-each-ref[1] by default, i.e. the `%(objectname) SPC
%(objecttype) TAB %(refname)` format. The `SPC %(objecttype)` part of
it is accepted but otherwise ignored (we don't validate the supposed
type). This is for the convenience of piping
linkgit:git-for-each-ref[1] output into `git bundle create`:

----------------
$ git for-each-ref 'refs/remotes/origin' |
  git bundle create origin.bundle --stdin
----------------

When providing names for revisions the reference name validation is
loose. You should probably use forms such as `refs/heads/master`, but
in order to provide the flexibility of having a `HEAD` reference and
other such `.git/NAME` references, even a name like `top-level` is
supported. A name such as `top:level` is not, as it is not a valid ref
name in any context within git (characters like ":" are not allowed).

Thus it's possible to create bundles with nonsensical names that would
not be semantically accepted by some of git's more stricter checking,
e.g. tag object tips in a `refs/heads/*` namespace:

----------------
$ git for-each-ref 'refs/tags/v*' |
  sed 's!refs/tags/!refs/heads/!' |
  git bundle create bad-heads.bdl --stdin
----------------

The objects in such an odd bundle can be extracted, but "git fetch"
might not accept some of them.

THIN BUNDLES
------------

When creating a bundle it is very important that the basis used be held by the destination.
It is okay to err on the side of caution, causing the bundle file
to contain objects already in the destination, as these are ignored
when unpacking at the destination.

`git clone` can use any bundle created without negative refspecs
(e.g., `new`, but not `old..new`).
If you want to match `git clone --mirror`, which would include your
refs such as `refs/remotes/*`, use `--all`.
If you want to provide the same set of refs that a clone directly
from the source repository would get, use `--branches --tags` for
the `<git-rev-list-args>`.

See the `--thin` option to linkgit:git-pack-objects[1] and the
discussion of "thin pack" in link:technical/pack-format.html[the pack
format documentation] for further details.

EXAMPLES
--------

Assume you want to transfer the history from a repository R1 on machine A
to another repository R2 on machine B.
For whatever reason, direct connection between A and B is not allowed,
but we can move data from A to B via some mechanism (CD, email, etc.).
We want to update R2 with development made on the branch master in R1.

To bootstrap the process, you can first create a bundle that does not have
any basis. You can use a tag to remember up to what commit you last
processed, in order to make it easy to later update the other repository
with an incremental bundle:

----------------
machineA$ cd R1
machineA$ git bundle create file.bundle master
machineA$ git tag -f lastR2bundle master
----------------

Then you transfer file.bundle to the target machine B. Because this
bundle does not require any existing object to be extracted, you can
create a new repository on machine B by cloning from it:

----------------
machineB$ git clone -b master /home/me/tmp/file.bundle R2
----------------

This will define a remote called "origin" in the resulting repository that
lets you fetch and pull from the bundle. The $GIT_DIR/config file in R2 will
have an entry like this:

------------------------
[remote "origin"]
    url = /home/me/tmp/file.bundle
    fetch = refs/heads/*:refs/remotes/origin/*
------------------------

To update the resulting mine.git repository, you can fetch or pull after
replacing the bundle stored at /home/me/tmp/file.bundle with incremental
updates.

After working some more in the original repository, you can create an
incremental bundle to update the other repository:

----------------
machineA$ cd R1
machineA$ git bundle create file.bundle lastR2bundle..master
machineA$ git tag -f lastR2bundle master
----------------

You then transfer the bundle to the other machine to replace
/home/me/tmp/file.bundle, and pull from it.

----------------
machineB$ cd R2
machineB$ git pull
----------------

If you know up to what commit the intended recipient repository should
have the necessary objects, you can use that knowledge to specify the
basis, giving a cut-off point to limit the revisions and objects that go
in the resulting bundle. The previous example used the lastR2bundle tag
for this purpose, but you can use any other options that you would give to
the linkgit:git-log[1] command. Here are more examples:

You can use a tag that is present in both:

----------------
$ git bundle create mybundle v1.0.0..master
----------------

You can use a basis based on time:

----------------
$ git bundle create mybundle --since=10.days master
----------------

You can use the number of commits:

----------------
$ git bundle create mybundle -10 master
----------------

You can run `git-bundle verify` to see if you can extract from a bundle
that was created with a basis:

----------------
$ git bundle verify mybundle
----------------

This will list what commits you must have in order to extract from the
bundle and will error out if you do not have them.

A bundle from a recipient repository's point of view is just like a
regular repository which it fetches or pulls from. You can, for example, map
references when fetching:

----------------
$ git fetch mybundle master:localRef
----------------

You can also see what references it offers:

----------------
$ git ls-remote mybundle
----------------

GIT
---
Part of the linkgit:git[1] suite
